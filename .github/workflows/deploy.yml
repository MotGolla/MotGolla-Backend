# .github/workflows/main.yml
# 이 워크플로우는 Java 애플리케이션을 빌드하고, Docker 이미지를 Docker Hub에 푸시한 다음,
# EC2 인스턴스에 SSH로 접속하여 배포합니다.

name: Motgolla Backend CI/CD # 워크플로우 이름

on:
  push:
    branches:
      - main # main 브랜치에 푸시될 때 워크플로우 실행

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest # 이 작업은 최신 Ubuntu 러너에서 실행됩니다.
    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      ORACLE_DB_URL: ${{ secrets.ORACLE_DB_URL }}
      ORACLE_DB_USERNAME: ${{ secrets.ORACLE_DB_USERNAME }}
      ORACLE_DB_PASSWORD: ${{ secrets.ORACLE_DB_PASSWORD }}
      AWS_ACCESS_KEY: ${{ secrets.AWS_ACCESS_KEY }}
      AWS_SECRET_KEY: ${{ secrets.AWS_SECRET_KEY }}
      AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      SWAGGER_SERVER: ${{ secrets.SWAGGER_SERVER }}
    permissions:
      contents: read # 리포지토리 콘텐츠에 대한 읽기 권한 부여

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4 # 리포지토리 코드 체크아웃

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'gradle' # Gradle 종속성 캐싱 설정

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3 # Gradle 설정

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew # gradlew 스크립트 실행 권한 부여

      - name: Build with Gradle
        run: ./gradlew build -x test # Gradle 빌드 실행 (테스트 제외)

      - name: Set JAR name
        # 빌드된 JAR 파일의 이름을 환경 변수로 설정합니다.
        # build.gradle에 tasks.named('bootJar') { archiveFileName = 'app.jar' } 설정에 따라 'app.jar'로 가정합니다.
        run: echo "JAR_NAME=build/libs/app.jar" >> $GITHUB_ENV

      # Docker 이미지 빌드 및 Docker Hub에 push
      - name: Docker build & push to Docker Hub
        run: |
          # Docker Hub에 로그인합니다. 비밀번호는 GitHub Secrets에서 가져옵니다.
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          # Docker 이미지를 빌드합니다. JAR_FILE 인수는 이전 단계에서 설정된 환경 변수를 사용합니다.
          docker build \
            -t ${{ secrets.DOCKER_USERNAME }}/motgolla-backend:latest \
            --build-arg JAR_FILE=${{ env.JAR_NAME }} .
          # 빌드된 이미지를 Docker Hub에 푸시합니다.
          docker push ${{ secrets.DOCKER_USERNAME }}/motgolla-backend:latest

      # EC2 접속 후 배포 실행
      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1 # SSH를 통해 원격 서버에 명령을 실행하는 액션 사용
        with:
          host: ${{ secrets.EC2_HOST }} # EC2 인스턴스 IP 주소 (GitHub Secrets)
          username: ${{ secrets.EC2_USERNAME }} # EC2 인스턴스 사용자 이름 (예: ubuntu) (GitHub Secrets)
          key: ${{ secrets.EC2_PRIVATE_KEY }} # EC2 SSH 프라이빗 키 (GitHub Secrets)
          # 파일 복사를 위한 source 및 target 파라미터 수정
          source: "compose.yml" # GitHub Actions 러너의 현재 디렉토리에서 compose.yml 파일
          target: "/home/ubuntu/app" # EC2 인스턴스의 대상 디렉토리 (수정됨)
          script: |
            # EC2 인스턴스 내부에서 실행될 스크립트
            # 애플리케이션 디렉토리가 없으면 생성합니다.
            mkdir -p /home/ubuntu/app
            cd /home/ubuntu/app
            echo "Creating .env file with secrets..."
            # 기존 .env 파일이 존재하면 삭제
            [ -f .env ] && rm .env
            echo "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}" > .env
            echo "ORACLE_DB_URL=${{ secrets.ORACLE_DB_URL }}" >> .env
            echo "ORACLE_DB_USERNAME=${{ secrets.ORACLE_DB_USERNAME }}" >> .env
            echo "ORACLE_DB_PASSWORD=${{ secrets.ORACLE_DB_PASSWORD }}" >> .env
            echo "AWS_ACCESS_KEY=${{ secrets.AWS_ACCESS_KEY }}" >> .env
            echo "AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }}" >> .env
            echo "AWS_S3_BUCKET=${{ secrets.AWS_S3_BUCKET }}" >> .env
            echo "AWS_REGION=${{ secrets.AWS_REGION }}" >> .env
            echo "SWAGGER_SERVER=${{ secrets.SWAGGER_SERVER }}" >> .env
            echo ".env file created."
            # Docker Compose를 사용하여 서비스 배포
            # --pull: 항상 최신 이미지를 풀(pull)해옵니다.
            # --force-recreate: 기존 컨테이너를 강제로 다시 생성합니다.
            # -d: 백그라운드에서 실행합니다.
            echo "Pulling latest Docker images..."
            # 기존 컨테이너 중지 및 정리
            docker compose down --remove-orphans
            docker compose pull
            echo "Starting Docker Compose services..."
            docker compose up -d --force-recreate  --build

            echo "=== Waiting for application startup ==="
            sleep 20 # 애플리케이션 초기화 시간을 기다립니다.

            # 실행 중인 컨테이너 상태 확인
            echo "=== Container Status ==="
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            # 애플리케이션 로그 (최근 10줄)
            echo "=== Application Logs ==="
            docker logs --tail 10 motgolla-backend

            # 헬스 체크
            echo "=== Health Check ==="
            for i in {1..5}; do
              # 백엔드 애플리케이션의 헬스 체크 포트가 8080이므로 localhost:8080으로 변경
              if curl -f -s http://localhost:8080/actuator/health > /dev/null; then
                echo "Health check passed"
                break
              else
                echo "Health check attempt $i/5 failed, retrying..."
                sleep 3
              fi

              # 5번 시도 후에도 실패 시 로그 출력 후 배포 실패 처리
              if [ $i -eq 5 ]; then
                echo "Health check failed after 5 attempts"
                echo "=== Error Logs ==="
                docker logs --tail 20 motgolla-backend
                exit 1
              fi
            done

            # 오래된 사용되지 않는 Docker 이미지 정리
            docker image prune -f

            echo "Deployment completed successfully"